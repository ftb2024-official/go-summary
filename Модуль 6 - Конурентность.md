### <span style="color: lime">Что такое горутина?</span>
<span style="color: red">***Горутина***</span> - это легковесный поток выполнения в языке программирования Go. Она позволяет достичь как параллельности (запускаясь на нескольких ядрах процессора) так и конкурентности (когда несколько горутин запускаются на одном потоке и работают поочередно).

### <span style="color: lime">Горутина vs поток ОС</span>
<span style="color: red">***Горутины и потоки ОС***</span> имеют схожую цель - выполнения задач параллельно и конкурентно, но имеются различия между ними. Основные отличия между горутинами и потоками ОС:

#### 1. Легковесность:
- <span style="color: cyan">***Горутины***</span> очень легковесны. При создании горутины выделяется всего несколько килобайт (порядка 2 кБ) памяти для её стека.
- <span style="color: cyan">***Потоки ОС***</span> являются более "тяжёлыми". Каждый поток требует значительно больше ресурсов для создания, включая память для выделенного стека (обычно несколько мегабайт), а также расходы на переключение контекста между потоками.

#### 2. Управление:
- <span style="color: cyan">Горутины</span> управляются планировщиком Go.
- <span style="color: cyan">Потоки</span> управляются ОС.

#### 3. Производительность и масштабируемость:
- Поскольку <span style="color: cyan">горутины</span> легковесны и управляются на уровне Go, они масштабируются гораздо лучше, чем потоки ОС. Тысячи и миллионы горутин могут быть запущены одновременно.
- Переключение контекста между <span style="color: cyan">горутинами</span> менее дорогостоящее благодаря тому, что это происходит на уровне приложения.
- <span style="color: cyan">Потоки ОС</span> не так хорошо масштабируются. Из-за значительных накладных расходов, связанных с их созданием и переключением, количество одновременно работающих потоков ограничено.
- Производительность может падать при большом количестве <span style="color: cyan">потоков</span> из-за высокой стоимости синхронизации и переключения контекста.

### <span style="color: lime">Что такое канал?</span>
<span style="color: red">***Канал в Go***</span> это средство для обмена данными между горутинами. Каналы бывают <span style="color: red">буферизованными и небуферизованными</span>. 

<span style="color: red">Небуферизованные канал</span> передаёт данные синхронно: отправляющая и принимающая стороны блокируются до завершения операции получения/передачи.

<span style="color: red">Буферизованные каналы</span> позволяют отправлять несколько сообщений в канал без немедленной необходимости их получения. То есть, отправка данных не блокируется, пока в буфере есть свободное место. В <span style="color: red">буферизованном канале</span> передача данных блокируется только тогда, когда буфер полностью заполнен, а приём когда буфер пуст.

<span style="color: red">Аксиомы каналов</span>:
- Запись в неинициализированный канал приведет к блокировке.
```go
func main() {
	var ch chan int // ch неинициализированный канал типа int
	ch <- 1
}
```
- Чтение из неинициализированного канала приведет к блокировке.
```go
func main() {
	var ch chan int
	msg := <-ch
}
```
- Запись в закрытый канал приведет к панике.
```go
func main() {
	ch := make(chan int, 1)
	ch <- 1
	close(ch)
	ch <- 2
}
```

- Чтение из закрытого канала вернет оставшиеся данные, если данных не остались, то вернется дефолтное значение типа канала.
```go
func main() {
	ch := make(chan int, 1)
	ch <- 1
	close(ch)
	msg := <-ch // вернет 1
	msg = <-ch // вернет 0, потому-что 0 является дефолтным значением для типа int
}
```

### <span style="color: lime">Race condition</span>
<span style="color: red">***Это ситуация***</span>, когда несколько горутин или потоков одновременно читают и изменяют одно и то же значение без должной синхронизации.

### <span style="color: lime">Порядок выполнения select</span>
Порядок работы <span style="color: red">***select в Go***</span>:
<ul>
	<li>Проверяются все кейсы — готов ли канал к чтению или записи.</li>
	<li>Если несколько каналов готовы, выбирается случайный кейс.</li>
	<li>Если каналы не готовы, то:
		<ul>
			<li><span style="color: cyan">select</span> блокируется, если нет блока <span style="color: cyan">default</span>.</li>
			<li>Выполняется блок <span style="color: cyan">default</span>, если он есть.</li>
		</ul>
	</li>
</ul>

### <span style="color: lime">Как работает планировщик?</span>
<span style="color: red">***Планировщик Go***</span> работает по модели GMP, где "G" это горутина, "M" это поток ОС на котором будет выполняться код горутины, и "P" это логический процессор, куда будут прикрепляться горутины и они будут находиться в LRQ, а остальные горутины будут ждать в GRQ. Когда мы запустим программу на Go, планировщик будет ждать 1 из 4 событий.

События:
- Ключевое слово <span style="color: cyan">go</span>.
- Сборщик мусора.
- Системные вызовы: синхронные и асинхронные(net-poler).
- Блокирующие вызовы: синхронизация, оркестрация, вызов функций из языка Си.

### <span style="color: lime">Особенности работы с map в горутинах</span>
<span style="color: red">***map***</span> не потокобезопасен. В Go встроенный тип данных "map" не защищён от одновременной записи в него из разных горутин. Если несколько горутин пытаются одновременно изменять данные в карте, это приводит к гонке данных. Go автоматически проверяет гонки данных, и если обнаруживает их, программа завершится с ошибкой во время выполнения. Решением для проблемы являются следующие:
- использовать <span style="color: cyan">map + sync.Mutex</span> (эффективен в ситуациях, когда часто происходит изменение данных).
- использовать <span style="color: cyan">sync.Map</span> вместо <span style="color: cyan">map</span> (эффективен в ситуациях, когда редко происходит изменение данных, но активно используются операции чтения).
- использовать <span style="color: cyan">map + sync.RWMutex<span>.

### <span style="color: lime">Что такое deadlock?</span>
<span style="color: red">***Deadlock (взаимная блокировка)***</span> - это ситуация в многопоточных или параллельных программах, когда две или более горутины или потока находятся в состоянии ожидания друг друга, и ни один из них не может продолжить выполнение. Это приводит к тому, что программа зависает и не может завершить выполнение, так как все заблокированы.

### <span style="color: lime">Чем отличается Mutex от RW Mutex?</span>
Основные отличия между <span style="color: red">***Mutex от RW Mutex***</span>:
- <span style="color: cyan">Mutex</span> блокирует доступ к ресурсу для всех горутин (как читающих, так и записывающих), пока одна горутина владеет мьютексом.
- <span style="color: cyan">RWMutex</span> позволяет множеству горутин одновременно читать данные, но только одна горутина может записывать данные, блокируя и чтение, и запись для других горутин на время записи.

### <span style="color: lime">Какие недостатки у sync.Map?</span>
Основные недостатки <span style="color: red">***sync.Map***</span>:
<ul>
	<li>Медленнее для небольших карт: из-за более сложных внутренних механизмов для обеспечения конкурентного доступа на мало размерных картах приводят к доп.накладным расходам.</li>
	<li>Ограниченные операции: <span style="color: cyan">sync.Map</span> не поддерживает всех стандартных операций, доступных для обычных карт Go. Например:
	<ol>
		<li>Нельзя напрямую итерировать по карте с помощью стандартного оператора <span style="color: cyan">for-range</span>.</li>
		<li>Нет возможности напрямую проверять длину карты.</li>
	</ol>
	</li>
	<li>Отсутствие явной типизации: <span style="color: cyan">sync.Map</span> использует пустые интерфейсы <span style="color: cyan">interface{}</span> для хранения ключей и значений. Это приводит к отсутствию статической типизации, так как ключи и значения могут быть любыми типами.</li>
	<li>Оптимизирована для специфических сценариев: <span style="color: cyan">sync.Map</span> хорошо работает в сценариях, где часто выполняются операции чтения (в особенности, если карта в основном только читается) и есть небольшое количество записей.</li>
</ul>

### <span style="color: lime">Что лучше использовать: map + mutex или sync.Map?</span>
Использовать <span style="color: red">map + mutex, если</span>:
- Ваша карта содержит небольшое количество данных.
- Частота операций записи высока.
- Вам нужна строгая типизация и контроль над блокировками.
- Вам важно минимизировать накладные расходы.

Использовать <span style="color: red">sync.Map</span>, если:
- Ваши данные в основном читаются, а записи происходят редко.
- У вас много конкурентных горутин.
- Вам нужен простой и потокобезопасный доступ к карте без необходимости вручную управлять блокировками.

### <span style="color: lime">Какие бывают состояния у горутин?</span>
<span style="color: red">***Горутины***</span> могут быть в 1 из 3 состояний:
- <span style="color: cyan">Waiting</span>: Горутина ожидает завершения какой-либо операции.
- <span style="color: cyan">Runnable</span>: Горутина готова к выполнению, но в данный момент не выполняется, так как либо планировщик ещё не назначил ей процессорное время, либо все процессоры уже заняты другими горутинами.
- <span style="color: cyan">Running</span>: Горутина в данный момент выполняется. Она получила процессорное время и выполняет инструкции.

### <span style="color: lime">Типы многозадачности: вытесняющий и кооперативный</span>
<span style="color: red">***Вытесняющая многозадачность***</span> означает, что операционная система или планировщик самостоятельно решает, когда прерывать выполнение одной задачи (потока, горутины) и переключаться на выполнение другой задачи. Это делается независимо от того, что выполняет текущая задача. Задача может быть вытеснена в любой момент времени для того, чтобы другие задачи могли получить процессорное время.

<span style="color: red">Преимущества</span>:
- Позволяет обеспечить равномерное распределение ресурсов между задачами.
- Снижает риск того, что одна задача заблокирует выполнение всех остальных задач (например, если она зациклилась или выполняется слишком долго).
- Улучшает отзывчивость системы.

<span style="color: red">Недостатки</span>:
- Дополнительные накладные расходы на переключение контекста между задачами.
- Более сложная реализация, поскольку планировщик должен отслеживать состояние всех задач и управлять их переключением.

<span style="color: red">***Кооперативная многозадачность***</span> означает, что задачи (потоки, горутины) сами контролируют своё выполнение и решают, когда они готовы "уступить" процессорное время другим задачам. Планировщик не может прервать задачу до тех пор, пока она добровольно не передаст управление.

<span style="color: red">Преимущества</span>:
- Проще в реализации, так как планировщик не занимается принудительным переключением задач.
- Отсутствуют накладные расходы на принудительное переключение контекста задач.
- Может быть более эффективным в ситуациях, когда задачи естественным образом часто освобождают процессор (например, во время операций ввода-вывода).

<span style="color: red">Недостатки</span>:
- Если задача выполняется слишком долго или "зависает", она может заблокировать выполнение всех остальных задач.
- Требует дисциплины от разработчиков, так как каждая задача должна "вежливо" передавать управление другим задачам в нужный момент.
- Менее отзывчиво по сравнению с вытесняющей многозадачностью.

<span style="color: red">Заключение</span>:
- <span style="color: cyan">Вытесняющая многозадачность</span> (как в Go или современных ОС) предоставляет больше гибкости и надёжности, так как система может самостоятельно управлять задачами и предотвращать "зависание" отдельных задач.
- <span style="color: cyan">Кооперативная многозадачность</span> проще в реализации, но требует дисциплины от разработчиков, чтобы каждая задача своевременно передавала управление, иначе система может стать неотзывчивой.

### <span style="color: lime">Процесс переключение контекста управления</span>
<span style="color: red">***Переключение контекста управления (context switch)***</span> это процесс, при котором операционная система или планировщик задач сохраняет состояние выполняемой задачи (процесса, потока или горутины) и загружает состояние другой задачи для выполнения. Это позволяет эффективно организовать многозадачность и распределение ресурсов между несколькими выполняющимися задачами на одном или нескольких процессорах.

### <span style="color: lime">Пакет sync</span>
<span style="color: red">***Пакет sync***</span> предоставляет инструменты, которые помогают синхронизировать работу горутин (или потоков), чтобы избежать ошибок, связанных с одновременной записью или чтением данных.

Ключевые структуры из пакета <span style="color: red">sync</span>:
- Mutex: простой механизм блокировки, который гарантирует, что только одна горутина может получить доступ к общему ресурсу в конкретный момент времени. Остальные горутины, пытающиеся захватить мьютекс, будут ждать, пока он освободится.
- WaitGroup: позволяет ждать завершения набора горутин. Это полезно, когда нужно запустить несколько горутин и дождаться их завершения перед продолжением работы основной программы.
- RWMutex: позволяет разным горутинам одновременно читать данные, но блокирует доступ на запись, пока одна горутина записывает. Это полезно, когда большинство операций только читают данные, а запись происходит реже.
- Cond: используется для блокировки одной или нескольких горутин до тех пор, пока не произойдёт какое-то событие. Это своего рода механизм ожидания и уведомления.
- Once: гарантирует, что кусок кода будет выполнен только один раз, даже если несколько горутин пытаются его выполнить.