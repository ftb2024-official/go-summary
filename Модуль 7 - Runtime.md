### <span style="color: lime">Как работает стек?</span>
В контексте программирования на языке Go (и в целом), стек - это структура данных, которая работает по принципу LIFO (Last In, First Out), что означает "последний зашёл — первый вышел". Это можно представить как стопку тарелок: когда вы кладёте новую тарелку, она ложится сверху, а когда убираете — забираете также верхнюю. Когда программа выполняется, для каждого вызова функции создаётся кадр стека (stack frame).

Этот кадр содержит:
- Локальные переменные — переменные, объявленные внутри функции.
- Аргументы функции — данные, переданные функции при её вызове.
- Адрес возврата — информация о том, куда вернуться после завершения функции.

### <span style="color: lime">Как работает куча?</span>
В языке Go куча - это область памяти, где хранятся данные, которые могут жить дольше, чем один вызов функции. В отличие от стека, который работает по принципу LIFO (Last In, First Out) и используется для хранения локальных переменных, куча используется для более долгосрочных объектов, которые могут быть доступны из разных частей программы.

Основные моменты работы кучи в Go:
- Долговечность данных: Если переменная или объект должны "пережить" выполнение функции, где они были созданы, они помещаются в кучу. Это полезно, когда объект передаётся между функциями или должен существовать дольше одного вызова.

- Динамическое выделение памяти: Память в куче выделяется динамически — во время выполнения программы. Когда нужно создать новый объект, который может жить дольше текущего вызова функции, используется куча. Например, когда вы создаёте объект с помощью new() или make(), выделение происходит в куче.

- Автоматическое управление памятью: В Go нет необходимости вручную освобождать память. Вместо этого используется сборщик мусора (Garbage Collector, GC), который автоматически следит за тем, какие объекты больше не используются, и освобождает их, чтобы предотвратить утечки памяти.

### <span style="color: lime">Что быстрее: стек или куча?</span>
Стек быстрее, потому что выделение и освобождение памяти на нём происходит просто и последовательно, без сложного управления.

Куча медленнее из-за динамического выделения памяти и необходимости периодической работы сборщика мусора для освобождения неиспользуемых объектов.

### <span style="color: lime">Как понять когда переменная утекает в кучу, а когда остается в стеке?</span>
Go предоставляет специальный инструмент для `escape analysis`. Можно использовать флаг компиляции `-gcflags="-m"` для получения информации о том, какие переменные "утекли" в кучу.

Общие правила для понимания:
- Возвращаете указатель на переменную? — она будет выделена в куче.

- Захватываете переменную в замыкании? — она будет в куче.

- Передаёте указатель в другую функцию? — переменная, на которую ссылается указатель, окажется в куче.

- Используете локальную переменную только внутри функции? — она останется в стеке.

### <span style="color: lime">Что такое stop the world и сколько раз он выполняется?</span>
`Stop The World` - это момент, когда сборщик мусора останавливает выполнение всех горутин (всех параллельных процессов в Go) для того, чтобы провести определённые фазы своей работы. В это время программа не выполняет полезную работу, потому что все потоки остановлены. Это необходимо для того, чтобы сборщик мусора мог безопасно и точно отслеживать память, которая больше не используется, и освободить её.

За одну итерацию работы сборщика мусора, STW происходит 2 раза:


### <span style="color: lime">Захват значений переменных в defer</span>:
<span style="color: red">***Имеются три состояния по этому поводу***</span>:
- Значения переменных, переданные в отложенные функции через defer, захватываются на момент вызова defer.
```go
func main() {
	x := 10
	defer fmt.Println("value of x with defer:", x) // x = 10
	
	x = 20
	fmt.Println("value of x:", x) // x = 20
}
```

- Если используется замыкание (анонимная функция), которая ссылается на переменную, то отложенная функция будет видеть последнее значение переменной на момент её выполнения.

```go
func main() {
	x := 10
	defer func() {
		fmt.Println("value of x with closure:", x) // x = 20
	}()
	
	x = 20
	fmt.Println("value of x:", x) // x = 20
}
```
- Если ты хочешь, чтобы в defer использовалось текущее значение переменной, на момент вызова, можно передавать переменную в виде аргумента в отложенную функцию.
```go
func main() {
	x := 10
	defer func(val int) {
		fmt.Println("value of x(copy):",val) // x = 10
	}(x)
	
	x = 20
	fmt.Println("value of x:", x) // x = 20
}
```

### <span style="color: lime">Как вернуть ошибку внутри defer?</span>
В Go отложенные функции, вызванные через <span style="color: red">defer</span>, могут модифицировать значения возвращаемых параметров, включая ошибки. Если тебе нужно вернуть ошибку внутри <span style="color: red">defer</span>, то есть несколько подходов для этого. Давай рассмотрим эти методы на простых примерах:
- <span style="color: cyan">Изменение именованного возвращаемого значения</span>: В <span style="color: cyan" >Go</span> можно использовать именованные возвращаемые значения. Если функция возвращает ошибку и это значение объявлено в начале функции, то внутри <span style="color: cyan" >defer</span> можно изменить это именованное значение. После выполнения основного кода функции, <span style="color: cyan" >отложенная функция (defer)</span> выполнится и сможет изменить значение этой ошибки, если это необходимо.
```go
func doSmth() (err error) {
	defer func() {
		if err != nil {
			fmt.Println("Ошибка в defer:", err)
			err = errors.New("defer изменил ошибку")
		}
	}()

	err = errors.New("оригинальная ошибка")
	return
}

func main() {
	err := doSmth()
	fmt.Println("Возвращенная ошибка:", err)
}
```

- <span style="color: cyan" >Возврат ошибки через panic</span>: Еще один способ вернуть ошибку из <span style="color: cyan">defer</span> - это использование механизма <span style="color: cyan">panic</span>. Этот способ применяется реже, но он позволяет внутри <span style="color: cyan">defer</span> вызвать панику и потом обработать ее с помощью <span style="color: cyan">recover</span>.
```go
func doSmth() (err error) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Errorf("error catched: %v", r)
		}
	}()

	panic("smth went wrong")
	return nil
}

func main() {
	err := doSmth()
	fmt.Println("returned error:", err)
}
```